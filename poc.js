const express = require('express');
const jwt = require('jsonwebtoken'); // Importing jsonwebtoken
const { v4: uuidv4 } = require('uuid'); // UUID generation
const axios = require('axios'); // HTTP client
const dotenv = require('dotenv');
const fs = require('fs');
const path = require('path');



dotenv.config(); // Load environment variables from .env file

const app = express();
app.use(express.json()); // Middleware to parse JSON requests

// Secret key for JWT signing
const secretKey = process.env.SECRET_KEY || 'my_secret_key'; // Use a secure key in production

/**
 * A middleware that checks if a token is authorized.
 * @param {string} req - The bearer token generated by logging in
 * @param {*} res 
 * @param {*} next - Moves on to the next process once this middleware is complete.
 * @returns 
 */
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  jwt.verify(token, secretKey, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid or expired token' });
    }

    req.user = user; // Attach the user data to the request
    next(); // Move to the next middleware or route handler
  });
}

/**
 * Find objects in the data.json file based on the correlation ID.
 * @param {string} correlationId - The correlation ID to search for.
 * @returns {object[]} An array of objects with the specified correlation ID.
 */
const findObjectByCorrelationId = (correlationId, data) => {
  return data.find(obj => obj.correlationId === correlationId);
};



app.get('/', (req,res) => {
  res.json({"message": "Working"})
})

/**
 * This simulates logging in on a micropub site using a website. 
 * It allows you to get your token to be use in sending signals and accessing other apis.
 * @param {string} username
 * @param {string} password
 */
app.post('/login', (req, res) => {
  const { username, password } = req.body;

  if (username === 'admin' && password === 'password') {
    // Generate a token valid for 1 hour
    const token = jwt.sign({ username: 'admin' }, secretKey, { expiresIn: '1h' });
    res.json({ token });
  } else {
    res.status(401).json({ error: 'Invalid credentials' });
  }
});



/**
 * The endpoint where the signal is sent
 * This simulates that a signal has been received
 * To do: Should be able to add a feedback to the signal to end the loop.
 */
app.post('/signal', (req, res) => {
  console.log("Notifications received");

  // Get the received data from req.body
  const receivedData = req.body;

  // Convert the received data to JSON string
  const jsonData = JSON.stringify(receivedData, null, 2); // Pretty-print with indentation

  // Write the JSON data to the data.json file
  fs.writeFile('data.json', jsonData, (err) => {
      if (err) {
          console.error('Error writing to data.json:', err);
          res.status(500).json({ error: 'Internal server error' });
      } else {
          console.log('Data saved to data.json');
          res.status(200).json({ message: 'Signal received and saved' });
      }
  });
});

app.post('/get-data', (req, res) => {
  const { correlationId } = req.body;

  try {
    const data = fs.readFileSync('data.json', 'utf8');
    const parsedData = JSON.parse(data);

    // Find the object with the specified correlation ID
    const foundObject = parsedData.find(obj => obj.correlationId === correlationId);

    if (!foundObject) {
      return res.status(404).json({ error: 'No object found with the specified correlation ID' });
    }

    res.json(foundObject);
  } catch (err) {
    console.error('Error reading data.json:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/add-comment', (req, res) => {
  const { correlationId, message } = req.body; // Extract the correlationId and message from the request body

  // Read the existing JSON object from data.json
  const dataPath = path.join(__dirname, 'data.json');
  fs.readFile(dataPath, 'utf8', (err, data) => {
    if (err) {
      console.error('Error reading data.json:', err);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    let existingJson;
    try {
      existingJson = JSON.parse(data);
    } catch (parseErr) {
      console.error('Error parsing data.json:', parseErr);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    // Find the object with the matching correlationId and update it
    const updatedJson = { ...existingJson };
    if (updatedJson.correlationId === correlationId) {
      updatedJson.message = message;
    }

    // Check if the correlationId was found
    if (existingJson.correlationId !== correlationId) {
      return res.status(404).json({ error: 'Correlation ID not found' });
    }

    // Write the updated JSON object back to data.json
    fs.writeFile(dataPath, JSON.stringify(updatedJson, null, 2), err => {
      if (err) {
        console.error('Error writing data.json:', err);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
      // Send the updated JSON object in the response
      res.json(updatedJson);
    });
  });
});


/**
 * This simulates the sending of signal and gathering of data.
 * @param {string} provider
 * @param {datetime} start
 * @param {datetime} end
 * @param {datetime} published
 * @param {uuid} signalId
 * @param {uuid} correlationId
 * @param {list} category
 * @param {string} object
 * @param {string} predicate
 * @param {object} payload
 * @param {object} cnCodes
 * @param {string} countryOfOrigin
 * @param {string} commodityDescription
 * @param {object} chedNumbers
 * @param {object} unitIdentification
 * @param {string} mode
 * @param {string} exporterEORI
 * @param {string} importerEORI
 */
app.post('/pre-notification', authenticateToken, (req, res) => {
  const preNotificationData = {
    provider: req.body.provider,
    start: req.body.start,
    end: req.body.end,
    published: req.body.published,
    signalId: uuidv4(), // Generate a unique signal ID
    correlationId: uuidv4(), // Generate a unique correlation ID
    category: req.body.category || ["pre-notification"],
    object: req.body.object,
    predicate: req.body.predicate,
    payload: {
      cnCodes: req.body.payload.cnCodes,
      countryOfOrigin: req.body.payload.countryOfOrigin,
      commodityDescription: req.body.payload.commodityDescription,
      chedNumbers: req.body.payload.chedNumbers,
      unitIdentification: {
        containerNumber: req.body.payload.unitIdentification.containerNumber,
        trailerRegistrationNumber: req.body.payload.unitIdentification.trailerRegistrationNumber,
      },
      mode: req.body.payload.mode,
      exporterEORI: req.body.payload.exporterEORI,
      importerEORI: req.body.payload.importerEORI,
    },
  };

  console.log("Received pre-notification signal:", preNotificationData);

  // Simulate sending to another endpoint (e.g., ISN messaging infrastructure)
  const externalEndpoint = 'http://localhost:3000/signal';
  axios.post(externalEndpoint, preNotificationData, {
    headers: {
      'Authorization': `Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNzE4MTI4MDU2LCJleHAiOjE3MTgxMzE2NTZ9.QeYpBdf7kI9zNMqZEHKdntWjkJJllf0eZtq8rLvRsmE`, // Token for ISN communication
      'Content-Type': 'application/json',
    },
  })
  .then(response => {
    console.log("Response from ISN:", response.data);
    res.status(201).json({
      message: 'Pre-notification signal received and sent to ISN.',
      signal: preNotificationData,
    });
  })
  .catch(error => {
    console.error("Error sending pre-notification to ISN:", error);
    res.status(500).json({
      error: 'Internal server error while sending pre-notification.',
    });
  });
});

const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
